/*
 * generated by Xtext 2.24.0
 */
package org.xtext.assignment.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import org.xtext.assignment.mathCompilerDsl.MathExp
import javax.swing.JOptionPane
import org.xtext.assignment.mathCompilerDsl.Expression
import java.util.Map
import org.xtext.assignment.mathCompilerDsl.Plus
import org.xtext.assignment.mathCompilerDsl.Minus
import org.xtext.assignment.mathCompilerDsl.Mult
import org.xtext.assignment.mathCompilerDsl.Div
import org.xtext.assignment.mathCompilerDsl.Var
import org.xtext.assignment.mathCompilerDsl.Let
import java.util.HashMap
import org.xtext.assignment.mathCompilerDsl.MathLang
import java.util.List
import java.util.ArrayList

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class MathCompilerDslGenerator extends AbstractGenerator {
override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		val math = resource.allContents.filter(MathLang).next
		val result = math.compute
		val resultText = math.displayMath
		val sb = new StringBuilder()
		//System.out.println("Math expression = "+math.displayMath)
		// For +1 score, replace with hovering, see Bettini Chapter 8
		for (var i = 0; i<result.size; i++){
			 sb.append(resultText.get(i)+" = " + result.get(i))
			 sb.append("\n")
		}
		
		JOptionPane.showMessageDialog(null, sb.toString() ,"Math Language", JOptionPane.INFORMATION_MESSAGE)
		
		
		fsa.generateFile("MathComputation.java", math.generateJava)
	}
	
	
	def dispatch String generateJava(MathLang math)'''
	 public class MathComputation {
	    public static void main(String[] args) throws Exception {
	        MathComputation mc = new MathComputation();
	        mc.compute();
	    }
	
	    public void compute() {
	      «math.generateJavaMath»
	    }
	  }
	
	'''
		
	
	
	//
	// Compute function: computes value of expression
	// Note: written according to illegal left-recursive grammar, requires fix
	//
	
	def static List<Integer> compute(MathLang math) { 
		val List<Integer> list = new ArrayList();
		for (MathExp mathExp : math.mathList){
			list.add(mathExp.compute)
		}
		return list
	}
	
	def static int compute(MathExp math) { 
		math.exp.computeExp
//		math.exp.computeExpEnv(new HashMap<String,Integer>)
	}

	// Functional-style solution ignoring variable binding provided by xtext	
	def static int computeExpEnv(Expression exp, Map<String,Integer> env) {
		switch exp {
			Plus: exp.left.computeExpEnv(env)+exp.right.computeExpEnv(env)
			Minus: exp.left.computeExpEnv(env)-exp.right.computeExpEnv(env)
			Mult: exp.left.computeExpEnv(env)*exp.right.computeExpEnv(env)
			Div: exp.left.computeExpEnv(env)/exp.right.computeExpEnv(env)
			org.xtext.assignment.mathCompilerDsl.Number: exp.value
			Var: env.get(exp.ref.name)
			Let: exp.body.computeExpEnv(env.bind(exp.name,exp.binding.computeExpEnv(env)))
			default: throw new Error("Internal error")
		}
	}
	
	def static Map<String,Integer> bind(Map<String,Integer> env1, String name, int value) {
		val env2 = new HashMap<String,Integer>(env1)
		env2.put(name,value)
		env2
	}
	
	// Normal style using xtext binding, requires a scope provider
	def static int computeExp(Expression exp) {
		switch exp {
			Plus: exp.left.computeExp+exp.right.computeExp
			Minus: exp.left.computeExp-exp.right.computeExp
			Mult: exp.left.computeExp*exp.right.computeExp
			Div: exp.left.computeExp/exp.right.computeExp
			org.xtext.assignment.mathCompilerDsl.Number: exp.value
			Var: exp.ref.binding.computeExp
			Let: exp.body.computeExp
			default: throw new Error("Internal error")
		}
	}	

	//
	// Display function: show complete syntax tree
	// Note: written according to illegal left-recursive grammar, requires fix
	//
	
	def static List<String> displayMath(MathLang math) { 
		val List<String> list = new ArrayList();
		for (MathExp mathExp : math.mathList){
			list.add(mathExp.expName + " " + mathExp.display)
		}
		return list
	}
	
	def static String display(MathExp math) {
		math.exp.display
	}

	def static String display(Expression exp) {
		switch exp {
			Plus: "("+exp.left.display+"+"+exp.right.display+")"
			Minus: "("+exp.left.display+"-"+exp.right.display+")"
			Mult: exp.left.display+"*"+exp.right.display
			Div: exp.left.display+"/"+exp.right.display
			org.xtext.assignment.mathCompilerDsl.Number: Integer.toString(exp.value)
			Var: exp.ref.name
			Let: '''let «exp.name» = «exp.binding.display» in «exp.body.display»  end'''
			default: throw new Error("Internal error")
		}
	}
	
	
	def static String generateJavaMath(MathLang math) { 
		val List<String> list = new ArrayList();
		for (MathExp mathExp : math.mathList){
			list.add('System.out.println("' + mathExp.expName+ ' " + '+ mathExp.display + ");")
		}
		
		val sb = new StringBuilder
		for (String s : list){
			sb.append(s)
			sb.append("\n")
			
		}
		
		return sb.toString()
	}
	
}
